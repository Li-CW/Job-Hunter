# 【美团】美团一面，八股盛宴|0329

> 1. cookie和session的区别？
> 2. 如何实现session共享，你会怎么做？
> 3. 反向代理是起什么作用的？
> 4. 数据库主从复制
> 5. 深拷贝和浅拷贝的区别？
> 6. 用过哪些深拷贝的方法？
> 7. GC分几种
> 8. minGC和FullGC有什么区别？
> 9. 消息队列起什么作用？
> 10. MySQL的隔离级别有哪些？
> 11. 默认是什么隔离级别？
> 12. 可重复读是什么概念？读未提交？串行化？
> 13. MySQL中的索引树是怎么维护的？
> 14. 什么叫B+树？
> 15. 为什么要采用这种数据结构？
> 16. Linux的命令平时用到哪些?
> 17. Linux中查看某个进程占用率较高的话，用哪个命令？
> 18. 我们想查找一个日志文件，空指针异常，查这个关键字用哪个命令查找？ (不清楚)
> 19. 设计模式接触过哪些？
>
> 总结：自己Java基础不行，还需要继续巩固，多思考为什么要这么做，继续学下去
>
> [分享者thehou](https://www.nowcoder.com/feed/main/detail/67eaedce9b534acabd3c5a96a8ae518d)

> **[面经专栏直通车，欢迎订阅](https://www.nowcoder.com/creation/manager/columnDetail/0xKkDM)**

> **[面经专栏下载， 点击跳转](https://github.com/Li-CW/Job-Hunter)**  

## 1. cookie和session的区别？

**参考回答：**

> Cookie和Session在多个方面存在显著的区别，主要体现在以下几个方面：
>
> 1. **存储位置**：
>
> - Cookie的数据存储在客户端的浏览器中，用户可以通过浏览器工具查看和修改cookie信息。
> - Session的数据则存放在服务器上，用户无法直接访问服务器上的session数据。
>
> 2. **存储容量与类型**：
>
> - Cookie的存储容量相对较小，通常限制在4KB以内，并且只能存储字符串类型的数据。
> - Session的存储容量没有明确的限制（但考虑到服务器性能，通常不建议存放过多数据），并且它可以存储任意类型的数据。
>
> 3. **有效期与生命周期**：
>
> - Cookie的有效期可以在设置时指定，只要不超过设置的过期时间，它可以长期保存在客户端。
> - Session的生命周期则通常较短，它会在一定的操作时间（如30分钟）后失效，并且在用户关闭浏览器或会话结束时，Session数据会被清除。
>
> 4. **安全性**：
>
> - 由于Cookie存储在客户端，存在被第三方截获或篡改的风险，因此安全性相对较低。攻击者可以通过分析或伪造Cookie来欺骗系统。
> - Session数据存储在服务器上，相对更加安全，不容易被攻击者直接获取或修改。
>
> 5. **跨域支持**：
>
> - Cookie支持跨域名访问，即可以在不同的域名之间共享。
> - Session则通常与特定的客户端和服务器端关联，不支持跨域访问。
>
> 6. **对服务器压力**：
>
> - Cookie不占用服务器资源，因为数据存储在客户端。
> - Session则需要在服务器上存储数据，因此对服务器的资源占用和性能有一定影响。
>
> Cookie和Session都是在Web开发中用来跟踪用户会话状态的机制，区别如下：
>
> 1. **存储位置**：
>    - Cookie: 存储在用户浏览器中，以文本文件的形式保存在用户计算机上。
>    - Session: 存储在服务器端，通常以一种特殊的数据结构（如哈希表）保存在服务器的内存中或者持久化存储（如数据库）中。
> 2. **安全性**：
>    - Cookie: 可以在用户浏览器上被查看和修改，因此相对不太安全。但是可以通过设置Cookie的属性，如HTTPOnly和Secure，来提高安全性。
>    - Session: 存储在服务器端，相对于Cookie更安全，因为用户无法直接查看或修改会话数据。
> 3. **容量**：
>    - Cookie: 由于存储在用户浏览器中，单个Cookie的容量通常有限制（一般约为4KB），因此它适合存储少量的数据。
>    - Session: 存储在服务器端，通常没有明确的容量限制，但会受到服务器资源的限制。
> 4. **生命周期**：
>    - Cookie: 可以设置过期时间，也可以是会话Cookie（浏览器关闭后自动删除）。
>    - Session: 通常在用户关闭浏览器或者长时间不活动后过期，但也可以设置特定的过期时间。
> 5. **跨页面访问**：
>    - Cookie: 可以跨页面访问，即使用户跳转到其他页面，Cookie仍然会被发送到服务器。
>    - Session: 也可以跨页面访问，但需要在页面之间传递会话标识符（如Session ID）来实现。

**学习指引：**[Cookie和Session的区别（面试必备）](https://blog.csdn.net/chen13333336677/article/details/100939030)

## 2. 如何实现session共享？

**参考回答：**

> 实现session共享有多种方法，主要取决于你的应用架构和所使用的技术栈。以下是一些常见的方法来实现session共享：
>
> 1. **数据库存储**：
>    - 将session数据存储在数据库中，而不是仅仅存储在内存中。这样，无论请求发送到哪个服务器，都可以通过查询数据库来获取session数据。
>    - 这种方法需要设计好数据库表结构，并编写相应的存储和检索逻辑。
> 2. **缓存系统**：
>    - 使用像Redis或Memcached这样的缓存系统来存储session数据。每个服务器都可以访问这个共享的缓存系统来获取和更新session数据。
>    - 这种方法通常比数据库访问更快，并且能更好地处理大量并发请求。
> 3. **粘性session**：
>    - 通过负载均衡器实现粘性session（或称为持久连接）。负载均衡器根据某种算法（如基于IP哈希）将用户的请求始终路由到同一台服务器。
>    - 这种方法不需要跨服务器共享session数据，但可能导致服务器负载不均衡。
> 4. **Session复制**：
>    - 当一个服务器上的session数据发生变化时，将这些变化复制到其他服务器上。这通常通过消息队列（如RabbitMQ）或分布式事件系统（如Apache Kafka）实现。
>    - 这种方法的缺点是可能存在数据同步延迟，且在大规模部署中可能不太实用。
> 5. **中央认证服务**：
>    - 使用如OAuth、OpenID Connect或SAML等中央认证服务来管理用户的认证和授权信息。
>    - 用户登录后，认证服务会颁发一个令牌（token），客户端可以使用这个令牌来访问资源，而不需要依赖session数据。
> 6. **无状态应用**：
>    - 设计应用为无状态，即不依赖服务器端的session数据来识别用户。
>    - 可以通过JWT（JSON Web Tokens）或其他令牌机制来实现用户身份验证和授权。
> 7. **使用框架和库**：
>    - 某些Web框架和库提供了内置的session共享机制。例如，Spring Session可以与Redis或数据库集成来实现session共享。

**学习指引：**[如何实现session跨服务器共享](https://zhuanlan.zhihu.com/p/88117430)
## 3. 反向代理是起什么作用的？
**参考回答：**

> 反向代理是一种位于客户端和后端服务器之间的代理服务器模型，它接收来自客户端的请求，并将其转发到后端服务器，然后将响应返回给客户端。反向代理在多个方面发挥着重要的作用：
>
> 1. **负载均衡**：反向代理通过将请求分发到多个后端服务器，平衡负载，从而减少单个服务器的负担，提高系统的可伸缩性。对于流量较高的网站，这种分发机制可以确保服务器容量得到充分利用，以处理大量请求。如果某台服务器过载并出现故障，反向代理还可以将流量重定向至其他在线服务器，确保服务的连续性和稳定性。
> 2. **安全性和访问控制**：反向代理通过实现身份验证、授权和防火墙功能，增强了系统的安全性。它可以拦截所有传入请求，为后端服务器提供更高层级的保护。通过阻止来自特定IP地址的可疑流量，反向代理有助于防止恶意访问者滥用网页服务器。此外，反向代理还可以隐藏后端服务器的真实地址，进一步提高系统的安全性。
> 3. **缓存数据**：反向代理可以缓存经常请求的数据，减少对后端服务器的访问次数，提高系统的性能。对于需要存储大量信息流数据的大型用户，缓存机制可以有效降低网站服务器的负载，提高网站的响应速度和用户体验。
> 4. **服务治理**：通过反向代理，管理员可以监控和管理后端服务器的状态，包括健康检查、服务降级等，确保系统的稳定性和可靠性。

**学习指引：**[什么是反向代理？](https://zhuanlan.zhihu.com/p/230829571)

## 4. MySQL数据库主从复制原理？
**参考回答：**

> MySQL数据库的主从复制原理涉及主服务器（Master）和从服务器（Slave）之间的数据同步过程。以下是这个过程的详细解释：
>
> **主服务器（Master）操作**：
>
> 1. **二进制日志（Binary Log）记录**：当主服务器上的数据发生更改时（如INSERT、UPDATE或DELETE操作），这些更改会被记录到主服务器的二进制日志（通常称为binlog）中。二进制日志是MySQL用来记录数据库更改的日志文件，它包含了描述数据库更改的“事件”。
> 2. **发送二进制日志**：从服务器会定期向主服务器请求最新的二进制日志事件。一旦从服务器请求，主服务器会发送从上次同步点之后的二进制日志事件到从服务器。
>
> **从服务器（Slave）操作**：
>
> 1. **接收和写入中继日志（Relay Log）**：从服务器接收到主服务器发送的二进制日志事件后，首先将这些事件写入到本地的中继日志中。中继日志是从服务器用来临时存储从主服务器接收到的二进制日志事件的日志文件。
> 2. **执行SQL语句**：从服务器的一个SQL线程会读取中继日志中的事件，并将这些事件转换成对应的SQL语句，然后在从服务器上执行这些SQL语句。这样，从服务器上的数据就被更新为与主服务器一致。
>
> **复制延迟与同步**：
>
> 在实际运行中，由于网络延迟、从服务器负载等原因，从服务器的数据可能会稍微落后于主服务器。这种延迟是主从复制的一个常见问题，需要通过监控和管理来确保数据的及时同步。
>
> 此外，MySQL还提供了多种复制模式，如异步复制、半同步复制等，这些模式在数据同步的实时性和一致性方面有所不同，用户可以根据实际需求选择合适的复制模式。

**学习指引：**[超详细！MySQL如何实现主从复制和读写分离](https://blog.csdn.net/qq_41786285/article/details/109304126)

## 5. Java 的深拷贝和浅拷贝的区别？
**参考回答：**

> 在 Java 中，深拷贝和浅拷贝主要涉及到对象复制时处理对象属性和引用关系的方式。这两种拷贝方式的主要区别如下：
>
> **浅拷贝（Shallow Copy）**
>
> 浅拷贝是创建一个新对象，并复制原对象中的非引用类型数据（如 int、double、float 等基本数据类型），但对于引用类型数据（如对象、数组等），只复制其引用而不复制引用的对象。换句话说，浅拷贝对于非引用类型字段进行值传递，对引用类型字段进行引用传递。因此，如果原对象的引用类型字段被修改，浅拷贝后的对象也会受到影响。
>
> **深拷贝（Deep Copy）**
>
> 深拷贝则不同，它不仅创建一个新对象，并复制原对象中的非引用类型数据，还会递归地复制原对象中的引用类型数据。也就是说，对于原对象的引用类型字段，深拷贝会创建一个新的对象，并复制原引用对象的内容到新对象中。因此，如果原对象的引用类型字段被修改，深拷贝后的对象不会受到影响。

**学习指引：**[Java深入理解深拷贝和浅拷贝区别 ](https://blog.csdn.net/riemann_/article/details/87217229)

## 6. Java 有哪些深拷贝的方法？
**参考回答：**

> 在 Java 中，实现深拷贝的方法有多种：
>
> 1. **重写 `clone()` 方法**：Java 中的 `Object` 类提供了一个 `clone()` 方法，用于创建对象的副本。但是，默认情况下，`clone()` 方法执行的是浅拷贝。为了实现深拷贝，需要重写 `clone()` 方法，并在其中对对象的属性进行递归拷贝。
> 2. **使用序列化和反序列化**：Java 中的序列化和反序列化可以实现对象的深拷贝。通过将对象写入字节流，然后再从字节流中读取出来，就可以创建一个新的对象，而不是简单地复制引用。这种方式要求被复制的类及其所有被引用的类都必须实现 `Serializable` 接口。
> 3. **使用第三方库**：有些第三方库提供了深拷贝的功能，比如 Apache Commons Lang 和 Gson。这些库通常提供了更灵活和强大的深拷贝实现，可以处理更复杂的对象结构和关系。

**学习指引：**[Java如何对一个对象进行深拷贝？](https://blog.csdn.net/sssspider/article/details/101693928)

## 7. Java 的 GC分几种？
**参考回答：**

> Java的垃圾回收（GC）主要可以分为以下几种：
>
> 1. **按线程数分**：
>    - **串行垃圾回收器**：在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。
>    - **并行垃圾回收器**：使用多个线程同时执行垃圾回收工作，以提高垃圾回收的效率。
> 2. **按工作模式分**：
>    - **并发式垃圾回收器**：垃圾回收线程与应用程序线程同时运行，可以在垃圾回收的同时进行应用程序的执行。
>    - **独占式垃圾回收器（Stop the World）**：一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。
> 3. **按碎片处理方式分**：
>    - **压缩式垃圾回收器**：在垃圾回收后，会对内存空间进行整理，消除内存碎片。
>    - **非压缩式垃圾回收器**：在垃圾回收后，不整理内存空间，可能产生内存碎片。
> 4. **按工作的内存区间分**：
>    - **年轻代垃圾回收器**：主要负责回收新生代中的垃圾对象。
>    - **老年代垃圾回收器**：主要负责回收老年代中的垃圾对象。
> 5. **按垃圾回收种类分**：
>    - **Partial GC**：部分收集模式，可以是Young GC（只收集年轻代的GC）或Old GC（只收集老年代的GC）。
>    - **Mixed GC**：收集整个年轻代以及部分老年代的GC，例如G1收集器就有这种模式。
>    - **Full GC**：收集整个堆和方法区，堆是垃圾回收的主要区域，方法区很少会被回收。
>
> 在Java虚拟机（JVM）中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理。而Java堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法，年老代主要使用标记-整理垃圾回收算法。

**学习指引：**[Java常见的GC有哪些？](https://blog.csdn.net/qq_41936805/article/details/95903002)

## 8. Java 的 minGC和FullGC有什么区别？
**参考回答：**

> MinGC（通常指的是Minor GC或Young GC）和Full GC（也称为Major GC或Old Generation GC）是Java虚拟机（JVM）中两种不同的垃圾回收（GC）操作，它们主要针对的是堆内存中的不同部分，并且在执行时有着不同的特点。
>
> **Minor GC（Young GC）**：
>
> - 主要针对新生代（Young Generation）进行垃圾回收。新生代是堆内存中的一个区域，主要用于存放新创建的对象。
> - 由于新生代中的对象生命周期通常较短，因此Minor GC的执行频率通常较高，但每次回收的耗时相对较短。
> - Minor GC采用复制算法，将存活对象从一个内存区域复制到另一个内存区域，同时清理掉不再使用的对象。
>
> **Full GC（Major GC或Old Generation GC）**：
>
> - 涉及整个Java堆（Heap）的回收，包括年轻代、老年代（Old Generation），以及方法区（也称为永久代在JDK 7或之前的版本，或者元空间在JDK 8以后的版本）。
> - Full GC的执行时间通常较长，因为它需要扫描整个堆内存，识别不再存活的对象并进行清理。
> - Full GC可能导致系统停顿，因为在垃圾回收过程中，所有的应用线程都会被暂停，直到GC完成。
> - Full GC的触发条件通常与老年代的空间不足或需要整理碎片化的内存有关。
>
> Minor GC和Full GC的主要区别在于它们针对的堆内存区域不同，执行频率和耗时也不同。Minor GC主要关注新生代的垃圾回收，而Full GC则涉及整个堆内存的回收。在设计Java应用时，需要尽量减少Full GC的次数，以保证系统的性能。同时，可以通过优化代码、减少内存泄漏和不必要的对象引用等方式来降低垃圾回收的频率和耗时。

**学习指引：**[JVM: GC过程总结(minor GC 和 Full GC)](https://blog.csdn.net/weixin_42615068/article/details/102813947)

## 9. 消息队列用途有哪些？
**参考回答：**

> 消息队列是一种重要的中间件技术，用于在分布式系统中实现异步通信，它的用途非常广泛。以下是消息队列的一些常见用途：
>
> 1. **解耦**：消息队列可以将应用程序解耦，发送者和接收者之间不直接通信，而是通过消息队列进行通信。这样可以降低系统间的耦合度，提高系统的灵活性和可维护性。
> 2. **异步通信**：发送者发送消息到消息队列后即可立即返回，不需要等待接收者处理完消息。这种方式可以提高系统的响应速度和吞吐量。
> 3. **削峰填谷**：消息队列可以作为流量控制的工具，当系统负载较高时，可以将请求放入消息队列中，等待系统负载下降后再处理。这样可以平滑处理系统的高峰流量，保证系统的稳定性。
> 4. **异步任务处理**：将需要异步执行的任务发送到消息队列中，由后台工作线程消费消息并执行任务。这样可以提高系统的并发能力和处理效率。
> 5. **日志收集**：将系统产生的日志消息发送到消息队列中，由日志消费者进行处理、分析、存储或者展示。这样可以集中管理日志，并且降低日志处理对系统性能的影响。
> 6. **事件驱动架构**：消息队列可以用于构建事件驱动的架构，不同组件之间通过发送和接收消息来进行通信。这种架构可以实现系统的松耦合和高内聚，提高系统的可扩展性和可维护性。
> 7. **分布式系统集成**：在分布式系统中，消息队列可以用于不同系统之间的数据传输和集成，实现系统之间的解耦和通信。
> 8. **顺序性保证**：某些消息队列提供了消息的顺序性保证，可以确保消息按照发送的顺序进行处理，适用于一些有序性要求的场景。

**学习指引：**[新手也能看懂，消息队列其实很简单](https://zhuanlan.zhihu.com/p/52773169)

## 10. MySQL的隔离级别有哪些？
**参考回答：**

> MySQL提供了四种事务隔离级别，分别是读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。不同的隔离级别可以解决并发访问数据库时的各种问题，提供不同程度的隔离和数据一致性。
>
> 1. 读未提交（Read Uncommitted）：
>    - 最低的隔离级别，事务中的修改操作对其他事务是可见的，即未提交的修改可以被其他事务读取。
>    - 存在脏读（Dirty Read）问题，即一个事务读取到了另一个未提交事务的修改结果。
>
> 2. 读提交（Read Committed）：
>
> - - 事务中的修改操作在提交之前对其他事务是不可见的，只有已提交的修改才能被其他事务读取。
>   - 解决了脏读问题，但可能存在不可重复读（Non-repeatable Read）问题，即在同一事务内多次读取同一数据可能会得到不同的结果。
>
> 3. 可重复读（Repeatable Read）：
>
> - - 保证在同一事务内多次读取同一数据时，得到的结果始终一致。
>   - 解决了不可重复读问题，但可能存在幻读（Phantom Read）问题，即在同一事务内多次执行查询，得到的结果集不一致。
>
> 4. 串行化（Serializable）：
>
> - - 最高的隔离级别，完全隔离事务，确保事务串行执行，避免并发问题。
>   - 解决了幻读问题，但在高并发情况下会导致性能下降，因为事务需要串行执行。

**学习指引：**[MySQL的4种事务隔离级别你还不清楚吗？](https://www.zhihu.com/question/600077805)

## 11. MySQL默认是什么隔离级别？
**参考回答：**

> MySQL数据库的默认隔离级别是**可重复读（Repeatable Read）**。
>
> 在这个隔离级别下，同一个事务中多次读取同样记录的结果是一致的。这主要是因为MySQL使用了多版本并发控制（MVCC）机制来实现并发控制，避免了脏读和不可重复读的问题。但需要注意的是，可重复读隔离级别并不能完全避免幻读问题，即在事务执行过程中，其他事务可能插入或删除某些行，导致最终读取到的数据行数发生了变化。
>
> MySQL也支持其他三种隔离级别：读未提交、读已提交和串行化。
>
> 这些隔离级别在数据一致性和并发性能之间提供了不同的权衡。在实际应用中，可以根据具体的业务需求和性能要求来选择合适的隔离级别。如果需要更高的并发性和性能，可以考虑使用较低的隔离级别，如读已提交；而如果对数据一致性有更高的要求，可以选择更高的隔离级别，如串行化。但请注意，高隔离级别可能会带来更大的性能开销。

**学习指引：**[mysql默认事务隔离级别是什么？](https://blog.csdn.net/ksaar_/article/details/104495954)

## 12. 可重复读是什么概念？读未提交？串行化？
**参考回答：**

> 在MySQL中，不同的隔离级别决定了事务如何与其他事务并发执行以及数据的一致性和可见性。以下是关于“可重复读”、“读未提交”和“串行化”这三种隔离级别的概念解释：
>
> **可重复读（Repeatable Read）**
>
> **可重复读**是MySQL的默认隔离级别。在这个级别下，一旦事务开始，该事务内部对同一数据的多次读取结果都是一致的，即使其他事务在此期间修改了该数据并提交。这是通过多版本并发控制（MVCC）实现的，每个事务都可以看到一个数据的一致快照，就像是在事务开始时拍摄的照片一样。这确保了同一事务中的多次读取操作不会受到其他事务的影响。
>
> 然而，需要注意的是，虽然同一事务内的多次读取是一致的，但不同事务之间仍然可以并发修改数据，这可能导致“幻读”现象，即一个事务在读取某个范围内的记录时，另一个并发事务插入或删除了这个范围内的记录，导致前一个事务在后续的读取中看到了不同的行数。
>
> **读未提交（Read Uncommitted）**
>
> **读未提交**是最低的隔离级别。在这个级别下，一个事务可以读取到其他事务尚未提交的数据。这可能导致脏读（Dirty Read）问题，即读取到了未经验证的数据。如果其他事务回滚了这些未提交的数据，那么当前事务读取到的数据就是无效的或“脏”的。因此，读未提交隔离级别下，数据的一致性和可靠性无法得到保证。
>
> **串行化（Serializable）**
>
> **串行化**是最高的隔离级别。在这个级别下，事务是串行执行的，即一个事务必须等待前一个事务完成后才能开始执行。这确保了每个事务都能看到一个一致的数据视图，从而避免了脏读、不可重复读和幻读的问题。然而，由于事务是串行执行的，这大大降低了系统的并发性能，特别是在高并发场景下，可能导致性能瓶颈。
>
> 在选择隔离级别时，需要根据具体的应用场景和需求进行权衡。如果业务对数据一致性要求非常高，且可以牺牲一定的并发性能，那么可以选择串行化隔离级别。如果业务对并发性能有较高要求，且可以容忍一定程度的数据不一致性，那么可以选择较低的隔离级别，如可重复读或读已提交。

**学习指引：**[数据库隔离级别------串行化，可重复读，读提交，读未提交](https://blog.csdn.net/weixin_43081805/article/details/98493923)

## 13. MySQL中的索引树是怎么维护的？
**参考回答：**

> MySQL中的索引树（主要是B+树）的维护涉及多个方面，包括插入、删除和更新操作。这些操作都需要确保索引树的平衡和高效性。以下是关于MySQL中索引树维护的一些关键点：
>
> 1. **插入操作**：
>    - 当向表中插入新数据时，MySQL需要在索引树中找到合适的位置插入新的索引条目。
>    - 如果插入的位置在叶子节点且有空余空间，直接插入。
>    - 如果叶子节点已满，需要进行分裂操作。分裂后，可能需要向上层节点插入新的分裂键。
>    - 为了保持树的平衡，可能需要进行一系列的分裂和重新平衡操作。
> 2. **删除操作**：
>    - 当从表中删除数据时，相应的索引条目也需要从索引树中删除。
>    - 如果删除的索引条目位于叶子节点，并且删除后该节点还有足够的条目，直接删除即可。
>    - 如果删除后叶子节点条目过少（例如，少于某个阈值），可能需要与相邻的兄弟节点合并，或者从父节点“借用”条目。
>    - 如果合并或借用操作导致父节点也需要调整，这个过程可能会向上层传播。
> 3. **更新操作**：
>    - 更新操作在索引维护方面通常可以视为先删除旧条目，再插入新条目。
>    - 如果更新的键没有改变，可能只需要更新叶子节点中的值部分。
>    - 如果更新的键发生了改变，则需要在索引树中找到旧键的位置进行删除，并在新位置插入新键。
> 4. **索引树的优化和重建**：
>    - 随着数据的插入、删除和更新，索引树可能会变得不那么紧凑或平衡，这可能导致性能下降。
>    - 为了优化索引性能，MySQL提供了工具（如`OPTIMIZE TABLE`）来重建索引树，使其更加紧凑和平衡。
>    - 重建索引通常涉及创建一个新的索引树，并将旧树中的数据逐步迁移到新树中。完成后，新树会替换旧树。
> 5. **并发控制**：
>    - 在高并发环境下，多个事务可能同时尝试修改索引树。
>    - MySQL使用锁机制（如行锁、表锁或元数据锁）来确保索引树的并发修改不会导致数据不一致。
>    - 锁的使用和粒度取决于存储引擎（如InnoDB或MyISAM）和具体的配置。
> 6. **日志和恢复**：
>    - 为了确保在系统崩溃或其他故障情况下能够恢复数据，MySQL使用重做日志（如InnoDB的redo log）来记录对索引树的修改。
>    - 在系统启动时，MySQL可以读取这些日志并重新应用修改，以恢复索引树到一致的状态。

**学习指引：**[MySQL：插入数据时，是如何维护好不同索引的B+树的](https://blog.csdn.net/zhizhengguan/article/details/122134407)

## 14. 什么叫B+树？
**参考回答：**

> B+ 树是一种平衡树数据结构，通常用于实现有序的索引结构。它是 B 树的变种，在 B 树的基础上做了一些改进和优化。
>
> B+ 树的特点包括：
>
> 1. **有序性**：B+ 树的所有叶子节点被链接成一个有序链表，这使得范围查询和区间扫描变得更加高效。
> 2. **平衡性**：B+ 树保持平衡，即所有叶子节点到根节点的距离相同，这确保了检索效率的稳定性。
> 3. **多路性**：B+ 树的每个节点可以拥有多个子节点，通常被称为“多路平衡”，这降低了树的高度，减少了磁盘 I/O 次数，提高了检索效率。
> 4. **非叶子节点仅存储索引信息**：与 B 树不同，B+ 树的非叶子节点只存储索引信息，而不存储实际的数据，这使得 B+ 树的节点更小，能够容纳更多的索引条目。
> 5. **叶子节点存储数据记录**：B+ 树的叶子节点存储实际的数据记录，这样可以避免在非叶子节点存储大量的数据，减少了索引的维护成本。
>
> B+ 树通常被用于数据库系统中实现索引结构，特别是在关系型数据库管理系统（RDBMS）中，例如 MySQL、PostgreSQL 等。B+ 树的高效性和稳定性使得它成为了一种理想的索引结构，能够满足大多数数据库系统的需求。

**学习指引：**[什么是B+树？](https://blog.csdn.net/jiang_wang01/article/details/113739230)

## 15. 为什么要采用B+树最为索引？
**参考回答：**

> B+ 树通常被用作数据库系统中的索引结构，而不是其他类型的树，主要基于以下几个原因：
>
> 1. **高效的检索和范围查询**：B+ 树的有序性和平衡性使得在进行查找、范围查询或区间扫描时非常高效。由于所有叶子节点被链接成一个有序链表，因此范围查询的性能非常好，可以快速地找到满足条件的数据记录。
> 2. **稳定的检索性能**：B+ 树的平衡性确保了树的高度相对较小，因此检索操作的性能是稳定的，不会因为数据量的增加而显著下降。这使得 B+ 树适用于大型数据库系统，能够处理大量数据并保持高效的检索性能。
> 3. **适用于磁盘存储**：B+ 树的设计考虑了磁盘 I/O 操作的特点，通过多路平衡的节点结构和叶子节点存储数据记录的方式，减少了磁盘 I/O 次数，提高了数据访问的效率。这使得 B+ 树非常适合在磁盘上存储大型数据集，并且能够有效地利用磁盘空间。
> 4. **适用于范围查询**：B+ 树的有序叶子节点链表和多路平衡的节点结构使得范围查询的性能非常好。这对于数据库系统中经常需要执行的范围查询操作来说是至关重要的，例如按时间范围或者按字母顺序查询数据。
> 5. **易于扩展和维护**：B+ 树的平衡性和多路性使得它们易于扩展和维护。当数据库中的数据量增加时，可以很容易地添加新的索引条目，并且不会显著影响整个树的结构。此外，B+ 树的节点结构简单，易于实现和维护。
>
> B+ 树具有高效的检索性能、稳定的性能表现、适用于磁盘存储、适用于范围查询以及易于扩展和维护等优点，因此被广泛应用于数据库系统中作为索引结构。

**学习指引：**[面试官：为什么MySQL的索引要使用B+树，而不是其它树？比如B树？](https://www.zhihu.com/question/633493697)

## 16. Linux的命令平时用到哪些?
**参考回答：**

> 在日常使用 Linux 系统时，经常会使用以下一些常用的命令：
>
> 1. **文件和目录操作**：
>    - `ls`：列出当前目录下的文件和子目录。
>    - `cd`：切换工作目录。
>    - `pwd`：显示当前工作目录的路径。
>    - `mkdir`：创建新目录。
>    - `rm`：删除文件或目录。
>    - `cp`：复制文件或目录。
>    - `mv`：移动文件或目录。
>    - `touch`：创建空文件或更新文件的时间戳。
> 2. **文件查看和编辑**：
>    - `cat`：显示文件内容。
>    - `more` 或 `less`：分页查看文件内容。
>    - `head` 和 `tail`：分别显示文件的开头和结尾部分。
>    - `vi` 或 `vim`：文本编辑器，用于编辑文件。
> 3. **文件权限管理**：
>    - `chmod`：修改文件或目录的权限。
>    - `chown`：修改文件或目录的所有者。
>    - `chgrp`：修改文件或目录的所属组。
> 4. **系统信息查看**：
>    - `uname`：显示系统信息。
>    - `df`：显示磁盘空间使用情况。
>    - `free`：显示系统内存使用情况。
>    - `top`：实时显示系统资源占用情况。
>    - `ps`：显示当前进程信息。
> 5. **网络操作**：
>    - `ping`：测试网络连接。
>    - `ifconfig` 或 `ip`：显示和配置网络接口信息。
>    - `ssh`：远程登录到其他主机。
>    - `scp`：在本地和远程主机之间传输文件。
> 6. **压缩和解压缩**：
>    - `tar`：打包和解压缩文件。
>    - `gzip` 和 `gunzip`：压缩和解压缩文件。
> 7. **系统管理**：
>    - `shutdown`：关闭系统。
>    - `reboot`：重新启动系统。
>    - `service` 或 `systemctl`：管理系统服务。
>    - `cron`：定时执行任务。

**学习指引：**[常用Linux命令及其作用](https://blog.csdn.net/qq_40846669/article/details/119704069)

## 17. Linux中查看某个进程占用率较高的话，用哪个命令？
**参考回答：**

> 要查看 Linux 中某个进程的 CPU 和内存占用率较高的话，可以使用 `top` 命令。 `top` 命令是一个动态实时显示系统运行进程信息的命令行工具，可以列出当前系统中所有正在运行的进程，并按照 CPU 和内存占用率进行排序。
>
> 要查看某个进程的 CPU 和内存占用率，你可以按以下步骤操作：
>
> 1. 打开终端窗口。
> 2. 运行 `top` 命令。
> 3. 在 `top` 的交互界面中，你可以按下 `Shift + P` 来按 CPU 占用率排序，或者按下 `Shift + M` 来按内存占用率排序。这样就会把占用率较高的进程排到前面。
> 4. 找到的进程，查看其 CPU 和内存占用率以及其他相关信息。
>
> 此外，也可以使用 `htop` 命令，它是 `top` 命令的增强版，提供了更加友好和交互式的界面，并且支持鼠标操作。

## 18. 我们想查找一个日志文件，空指针异常，查这个关键字用哪个命令查找？ 
**参考回答：**

> 如果想在Linux系统中查找包含“空指针异常”关键字的日志文件，你可以使用`grep`命令。`grep`是一个强大的文本搜索工具，它可以搜索含有特定模式的行。
>
> 以下是如何使用`grep`命令来查找包含“空指针异常”关键字的日志文件：
>
> ```bash
> grep -r "空指针异常" /path/to/logs/
> ```
>
> 这里的参数解释如下：
>
> - `-r` 或 `-R`：递归搜索，即在指定目录及其子目录中搜索。
> - `"空指针异常"`：你要搜索的关键字或模式。
> - `/path/to/logs/`：你要搜索的目录路径。你需要替换为实际的日志文件所在目录。
>
> 如果你想忽略大小写，可以使用`-i`选项：
>
> ```bash
> grep -ri "空指针异常" /path/to/logs/
> ```
>
> 如果你还想看到匹配行的行号，可以添加`-n`选项：
>
> ```bash
> grep -rin "空指针异常" /path/to/logs/
> ```
>
> 如果你知道日志文件的具体名称或模式，你还可以结合使用`find`命令和`xargs`或`-exec`选项来更精确地搜索。例如，如果你知道所有的日志文件都是以`.log`结尾的，你可以这样做：
>
> ```bash
> find /path/to/logs/ -name "*.log" -print0 | xargs -0 grep -i "空指针异常"
> ```
>
> 或者：
>
> ```bash
> find /path/to/logs/ -name "*.log" -exec grep -i "空指针异常" {} +
> ```
>
> 这些命令会搜索`/path/to/logs/`目录及其子目录中所有以`.log`结尾的文件，并查找包含“空指针异常”的行。记得将`/path/to/logs/`替换为你的实际日志文件路径。

> **[面经专栏直通车，欢迎订阅](https://www.nowcoder.com/creation/manager/columnDetail/0xKkDM)**

> **[面经专栏下载， 点击跳转](https://github.com/Li-CW/Job-Hunter)**  